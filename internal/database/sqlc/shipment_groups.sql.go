// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: shipment_groups.sql

package db

import (
	"context"
	"database/sql"
)

const CreateShipmentGroup = `-- name: CreateShipmentGroup :execresult


INSERT INTO shipment_groups (
    project_id, template_id, num_sets, tax_type,
    reverse_charge, status, created_by
) VALUES (?, ?, ?, ?, ?, ?, ?)
`

type CreateShipmentGroupParams struct {
	ProjectID     int64
	TemplateID    sql.NullInt64
	NumSets       int64
	TaxType       string
	ReverseCharge string
	Status        string
	CreatedBy     sql.NullInt64
}

// shipment_groups.sql
// sqlc-annotated queries for shipment groups and their associated delivery challans.
//
// Actual shipment_groups schema (from migrations 00024 + 00025):
//
//	id, project_id, template_id, num_sets, tax_type, reverse_charge,
//	status, created_by, created_at, updated_at
//
// delivery_challans gained: shipment_group_id, bill_from_address_id,
//
//	dispatch_from_address_id (migration 00025).
//
// =============================================================================
// Create
// =============================================================================
func (q *Queries) CreateShipmentGroup(ctx context.Context, arg CreateShipmentGroupParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, CreateShipmentGroup,
		arg.ProjectID,
		arg.TemplateID,
		arg.NumSets,
		arg.TaxType,
		arg.ReverseCharge,
		arg.Status,
		arg.CreatedBy,
	)
}

const GetShipmentGroup = `-- name: GetShipmentGroup :one

SELECT
    sg.id,
    sg.project_id,
    sg.template_id,
    sg.num_sets,
    sg.tax_type,
    sg.reverse_charge,
    sg.status,
    sg.created_by,
    sg.created_at,
    sg.updated_at,
    t.name                     AS template_name,
    p.name                     AS project_name,
    tdc.id                     AS transit_dc_id,
    tdc.dc_number              AS transit_dc_number,
    (
        SELECT COUNT(*)
        FROM delivery_challans dc2
        WHERE dc2.shipment_group_id = sg.id
          AND dc2.dc_type = 'official'
    )                          AS official_dc_count
FROM shipment_groups sg
LEFT JOIN dc_templates t      ON sg.template_id = t.id
LEFT JOIN projects p          ON sg.project_id  = p.id
LEFT JOIN delivery_challans tdc
       ON tdc.shipment_group_id = sg.id
      AND tdc.dc_type           = 'transit'
WHERE sg.id =
`

type GetShipmentGroupRow struct {
	ID              int64
	ProjectID       int64
	TemplateID      sql.NullInt64
	NumSets         int64
	TaxType         string
	ReverseCharge   string
	Status          string
	CreatedBy       sql.NullInt64
	CreatedAt       sql.NullTime
	UpdatedAt       sql.NullTime
	TemplateName    sql.NullString
	ProjectName     sql.NullString
	TransitDcID     sql.NullInt64
	TransitDcNumber sql.NullString
	OfficialDcCount int64
}

// =============================================================================
// Reads — single group
// =============================================================================
// Returns the group with joined template name, project name, transit DC info,
// and a correlated sub-query for official DC count.
func (q *Queries) GetShipmentGroup(ctx context.Context, id int64) (GetShipmentGroupRow, error) {
	row := q.db.QueryRowContext(ctx, GetShipmentGroup, id)
	var i GetShipmentGroupRow
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.TemplateID,
		&i.NumSets,
		&i.TaxType,
		&i.ReverseCharge,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TemplateName,
		&i.ProjectName,
		&i.TransitDcID,
		&i.TransitDcNumber,
		&i.OfficialDcCount,
	)
	return i, err
}

const GetShipmentGroupDCs = `-- name: GetShipmentGroupDCs :many
ESC;

SELECT
    dc.id,
    dc.project_id,
    dc.dc_number,
    dc.dc_type,
    dc.status,
    dc.challan_date,
    dc.created_at,
    dc.updated_at
FROM delivery_challans dc
WHERE dc.shipment_group_id = ?
ORDER BY dc.dc_type DESC, d
`

type GetShipmentGroupDCsRow struct {
	ID          int64
	ProjectID   int64
	DcNumber    string
	DcType      string
	Status      string
	ChallanDate sql.NullTime
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
}

// Returns all delivery challans belonging to a shipment group.
// (Identical query also used by GetDCsByShipmentGroup in delivery_challans.go.)
func (q *Queries) GetShipmentGroupDCs(ctx context.Context, shipmentGroupID sql.NullInt64) ([]GetShipmentGroupDCsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetShipmentGroupDCs, shipmentGroupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetShipmentGroupDCsRow{}
	for rows.Next() {
		var i GetShipmentGroupDCsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.DcNumber,
			&i.DcType,
			&i.Status,
			&i.ChallanDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetShipmentGroupIDByDCID = `-- name: GetShipmentGroupIDByDCID :one
?;

SELECT shipment_group_id
FROM delivery_challans
WHERE id                  = ?
  AND shipment_group_id IS NOT NU
`

// Fetches the shipment_group_id for a delivery challan (used by GetShipmentGroupByDCID
// in Go, which then calls GetShipmentGroup).
func (q *Queries) GetShipmentGroupIDByDCID(ctx context.Context, id int64) (sql.NullInt64, error) {
	row := q.db.QueryRowContext(ctx, GetShipmentGroupIDByDCID, id)
	var shipment_group_id sql.NullInt64
	err := row.Scan(&shipment_group_id)
	return shipment_group_id, err
}

const GetShipmentGroupsByProjectID = `-- name: GetShipmentGroupsByProjectID :many
L;


SELECT
    sg.id,
    sg.project_id,
    sg.template_id,
    sg.num_sets,
    sg.tax_type,
    sg.reverse_charge,
    sg.status,
    sg.created_by,
    sg.created_at,
    sg.updated_at,
    COALESCE(t.name, '')       AS template_name,
    (
        SELECT COUNT(*)
        FROM delivery_challans dc2
        WHERE dc2.shipment_group_id = sg.id
          AND dc2.dc_type = 'official'
    )                          AS official_dc_count,
    COALESCE(tdc.dc_number, '') AS transit_dc_number,
    tdc.id                      AS transit_dc_id
FROM shipment_groups sg
LEFT JOIN dc_templates t      ON sg.template_id = t.id
LEFT JOIN delivery_challans tdc
       ON tdc.shipment_group_id = sg.id
      AND tdc.dc_type           = 'transit'
WHERE sg.project_id = ?
ORDER BY sg.created_at
`

type GetShipmentGroupsByProjectIDRow struct {
	ID              int64
	ProjectID       int64
	TemplateID      sql.NullInt64
	NumSets         int64
	TaxType         string
	ReverseCharge   string
	Status          string
	CreatedBy       sql.NullInt64
	CreatedAt       sql.NullTime
	UpdatedAt       sql.NullTime
	TemplateName    string
	OfficialDcCount int64
	TransitDcNumber string
	TransitDcID     sql.NullInt64
}

// =============================================================================
// Reads — list
// =============================================================================
// Returns all shipment groups for a project with summary computed columns.
func (q *Queries) GetShipmentGroupsByProjectID(ctx context.Context, projectID int64) ([]GetShipmentGroupsByProjectIDRow, error) {
	rows, err := q.db.QueryContext(ctx, GetShipmentGroupsByProjectID, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetShipmentGroupsByProjectIDRow{}
	for rows.Next() {
		var i GetShipmentGroupsByProjectIDRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.TemplateID,
			&i.NumSets,
			&i.TaxType,
			&i.ReverseCharge,
			&i.Status,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TemplateName,
			&i.OfficialDcCount,
			&i.TransitDcNumber,
			&i.TransitDcID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const IssueAllDCsInGroup = `-- name: IssueAllDCsInGroup :execresult
= ?;

UPDATE delivery_challans
SET status     = 'issued',
    issued_at  = ?,
    issued_by  = ?,
    updated_at = ?
WHERE shipment_group_id = ?
  AND status            = 'dr
`

type IssueAllDCsInGroupParams struct {
	IssuedAt        sql.NullTime
	IssuedBy        sql.NullInt64
	UpdatedAt       sql.NullTime
	ShipmentGroupID sql.NullInt64
}

// Issues every draft DC in a shipment group atomically.
func (q *Queries) IssueAllDCsInGroup(ctx context.Context, arg IssueAllDCsInGroupParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, IssueAllDCsInGroup,
		arg.IssuedAt,
		arg.IssuedBy,
		arg.UpdatedAt,
		arg.ShipmentGroupID,
	)
}

const UpdateShipmentGroupStatus = `-- name: UpdateShipmentGroupStatus :exec
.id;


UPDATE shipment_groups
SET status     = ?,
    updated_at = ?
WHERE id
`

type UpdateShipmentGroupStatusParams struct {
	Status    string
	UpdatedAt sql.NullTime
	ID        int64
}

// =============================================================================
// Updates
// =============================================================================
func (q *Queries) UpdateShipmentGroupStatus(ctx context.Context, arg UpdateShipmentGroupStatusParams) error {
	_, err := q.db.ExecContext(ctx, UpdateShipmentGroupStatus, arg.Status, arg.UpdatedAt, arg.ID)
	return err
}
