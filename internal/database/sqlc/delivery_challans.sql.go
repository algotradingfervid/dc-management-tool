// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: delivery_challans.sql

package db

import (
	"context"
	"database/sql"
)

const CheckSingleSerialInProject = `-- name: CheckSingleSerialInProject :many
SELECT
    sn.serial_number,
    li.id AS line_item_id,
    dc.id AS dc_id,
    dc.dc_number,
    dc.status,
    p.item_name AS product_name
FROM serial_numbers sn
INNER JOIN dc_line_items li ON sn.line_item_id = li.id
INNER JOIN delivery_challans dc ON li.dc_id = dc.id
INNER JOIN products p ON li.product_id = p.id
WHERE sn.project_id    = ?
  AND sn.serial_number =
`

type CheckSingleSerialInProjectParams struct {
	ProjectID    int64
	SerialNumber string
}

type CheckSingleSerialInProjectRow struct {
	SerialNumber string
	LineItemID   int64
	DcID         int64
	DcNumber     string
	Status       string
	ProductName  string
}

// NOTE: Single-serial variant of CheckSerialsInProject (variable IN list is not
// statically analysable by sqlc — the multi-serial version stays in hand-written Go).
// This variant is useful for single-serial validation calls.
func (q *Queries) CheckSingleSerialInProject(ctx context.Context, arg CheckSingleSerialInProjectParams) ([]CheckSingleSerialInProjectRow, error) {
	rows, err := q.db.QueryContext(ctx, CheckSingleSerialInProject, arg.ProjectID, arg.SerialNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CheckSingleSerialInProjectRow{}
	for rows.Next() {
		var i CheckSingleSerialInProjectRow
		if err := rows.Scan(
			&i.SerialNumber,
			&i.LineItemID,
			&i.DcID,
			&i.DcNumber,
			&i.Status,
			&i.ProductName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const CheckSingleSerialInProjectByProduct = `-- name: CheckSingleSerialInProjectByProduct :many
?;

SELECT
    sn.serial_number,
    li.id AS line_item_id,
    dc.id AS dc_id,
    dc.dc_number,
    dc.status,
    p.item_name AS product_name
FROM serial_numbers sn
INNER JOIN dc_line_items li ON sn.line_item_id = li.id
INNER JOIN delivery_challans dc ON li.dc_id = dc.id
INNER JOIN products p ON li.product_id = p.id
WHERE sn.project_id    = ?
  AND sn.product_id    = ?
  AND sn.serial_number =
`

type CheckSingleSerialInProjectByProductParams struct {
	ProjectID    int64
	ProductID    sql.NullInt64
	SerialNumber string
}

type CheckSingleSerialInProjectByProductRow struct {
	SerialNumber string
	LineItemID   int64
	DcID         int64
	DcNumber     string
	Status       string
	ProductName  string
}

// NOTE: Single-serial variant of CheckSerialsInProjectByProduct (variable IN list
// stays in hand-written Go for the multi-serial version).
func (q *Queries) CheckSingleSerialInProjectByProduct(ctx context.Context, arg CheckSingleSerialInProjectByProductParams) ([]CheckSingleSerialInProjectByProductRow, error) {
	rows, err := q.db.QueryContext(ctx, CheckSingleSerialInProjectByProduct, arg.ProjectID, arg.ProductID, arg.SerialNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CheckSingleSerialInProjectByProductRow{}
	for rows.Next() {
		var i CheckSingleSerialInProjectByProductRow
		if err := rows.Scan(
			&i.SerialNumber,
			&i.LineItemID,
			&i.DcID,
			&i.DcNumber,
			&i.Status,
			&i.ProductName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const DeleteDeliveryChallan = `-- name: DeleteDeliveryChallan :exec
DELETE FROM delivery_challans WHERE id = ?
`

// Step 4 of DeleteDC transaction: remove the DC record itself.
func (q *Queries) DeleteDeliveryChallan(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, DeleteDeliveryChallan, id)
	return err
}

const DeleteLineItemsByDCID = `-- name: DeleteLineItemsByDCID :exec
DELETE FROM dc_line_items WHERE dc_id = ?
`

// Step 2 of DeleteDC transaction: remove line items for a DC.
func (q *Queries) DeleteLineItemsByDCID(ctx context.Context, dcID int64) error {
	_, err := q.db.ExecContext(ctx, DeleteLineItemsByDCID, dcID)
	return err
}

const DeleteSerialNumbersByDCID = `-- name: DeleteSerialNumbersByDCID :exec
DELETE FROM serial_numbers
WHERE line_item_id IN (
    SELECT id FROM dc_line_items WHERE dc_id = ?
)
`

// Step 1 of DeleteDC transaction: remove serial numbers for all line items of a DC.
func (q *Queries) DeleteSerialNumbersByDCID(ctx context.Context, dcID int64) error {
	_, err := q.db.ExecContext(ctx, DeleteSerialNumbersByDCID, dcID)
	return err
}

const DeleteTransitDetailsByDCID = `-- name: DeleteTransitDetailsByDCID :exec
DELETE FROM dc_transit_details WHERE dc_id = ?
`

// Step 3 of DeleteDC transaction: remove transit details (may not exist for official DCs).
func (q *Queries) DeleteTransitDetailsByDCID(ctx context.Context, dcID int64) error {
	_, err := q.db.ExecContext(ctx, DeleteTransitDetailsByDCID, dcID)
	return err
}

const GetAllAddressesByConfigID = `-- name: GetAllAddressesByConfigID :many
?;


SELECT
    id, config_id, address_data, district_name, mandal_name, mandal_code,
    created_at, updated_at
FROM addresses
WHERE config_id = ?
ORDER B
`

type GetAllAddressesByConfigIDRow struct {
	ID           int64
	ConfigID     int64
	AddressData  string
	DistrictName string
	MandalName   string
	MandalCode   string
	CreatedAt    sql.NullTime
	UpdatedAt    sql.NullTime
}

// =============================================================================
// Addresses (dropdown helper — lives in delivery_challans.go in Go code)
// =============================================================================
func (q *Queries) GetAllAddressesByConfigID(ctx context.Context, configID int64) ([]GetAllAddressesByConfigIDRow, error) {
	rows, err := q.db.QueryContext(ctx, GetAllAddressesByConfigID, configID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllAddressesByConfigIDRow{}
	for rows.Next() {
		var i GetAllAddressesByConfigIDRow
		if err := rows.Scan(
			&i.ID,
			&i.ConfigID,
			&i.AddressData,
			&i.DistrictName,
			&i.MandalName,
			&i.MandalCode,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetDCsByProjectID = `-- name: GetDCsByProjectID :many
SELECT
    dc.id, dc.project_id, dc.dc_number, dc.dc_type, dc.status,
    dc.challan_date, dc.created_at, dc.updated_at
FROM delivery_challans dc
WHERE dc.project_id = ?
ORDER BY dc.created_at DESC
`

type GetDCsByProjectIDRow struct {
	ID          int64
	ProjectID   int64
	DcNumber    string
	DcType      string
	Status      string
	ChallanDate sql.NullTime
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
}

// NOTE: dc_type filter is optional; Go builds this conditionally.
// Two variants are provided: unfiltered and type-filtered.
func (q *Queries) GetDCsByProjectID(ctx context.Context, projectID int64) ([]GetDCsByProjectIDRow, error) {
	rows, err := q.db.QueryContext(ctx, GetDCsByProjectID, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDCsByProjectIDRow{}
	for rows.Next() {
		var i GetDCsByProjectIDRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.DcNumber,
			&i.DcType,
			&i.Status,
			&i.ChallanDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetDCsByProjectIDAndType = `-- name: GetDCsByProjectIDAndType :many
SELECT
    dc.id, dc.project_id, dc.dc_number, dc.dc_type, dc.status,
    dc.challan_date, dc.created_at, dc.updated_at
FROM delivery_challans dc
WHERE dc.project_id = ?
  AND dc.dc_type = ?
ORDER BY dc.created_at DESC
`

type GetDCsByProjectIDAndTypeParams struct {
	ProjectID int64
	DcType    string
}

type GetDCsByProjectIDAndTypeRow struct {
	ID          int64
	ProjectID   int64
	DcNumber    string
	DcType      string
	Status      string
	ChallanDate sql.NullTime
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
}

func (q *Queries) GetDCsByProjectIDAndType(ctx context.Context, arg GetDCsByProjectIDAndTypeParams) ([]GetDCsByProjectIDAndTypeRow, error) {
	rows, err := q.db.QueryContext(ctx, GetDCsByProjectIDAndType, arg.ProjectID, arg.DcType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDCsByProjectIDAndTypeRow{}
	for rows.Next() {
		var i GetDCsByProjectIDAndTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.DcNumber,
			&i.DcType,
			&i.Status,
			&i.ChallanDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetDCsByShipmentGroup = `-- name: GetDCsByShipmentGroup :many
SELECT
    dc.id, dc.project_id, dc.dc_number, dc.dc_type, dc.status,
    dc.challan_date, dc.created_at, dc.updated_at
FROM delivery_challans dc
WHERE dc.shipment_group_id = ?
ORDER BY dc.dc_type DESC, dc.id
`

type GetDCsByShipmentGroupRow struct {
	ID          int64
	ProjectID   int64
	DcNumber    string
	DcType      string
	Status      string
	ChallanDate sql.NullTime
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
}

func (q *Queries) GetDCsByShipmentGroup(ctx context.Context, shipmentGroupID sql.NullInt64) ([]GetDCsByShipmentGroupRow, error) {
	rows, err := q.db.QueryContext(ctx, GetDCsByShipmentGroup, shipmentGroupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDCsByShipmentGroupRow{}
	for rows.Next() {
		var i GetDCsByShipmentGroupRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.DcNumber,
			&i.DcType,
			&i.Status,
			&i.ChallanDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetDeliveryChallanByID = `-- name: GetDeliveryChallanByID :one
SELECT
    d.id, d.project_id, d.dc_number, d.dc_type, d.status,
    d.template_id, d.bill_to_address_id, d.ship_to_address_id,
    d.challan_date, d.issued_at, d.issued_by, d.created_by,
    d.created_at, d.updated_at,
    d.bundle_id, d.shipment_group_id, d.bill_from_address_id,
    d.dispatch_from_address_id,
    t.name AS template_name
FROM delivery_challans d
LEFT JOIN dc_templates t ON d.template_id = t.id
WHERE d.id = ?
`

type GetDeliveryChallanByIDRow struct {
	ID                    int64
	ProjectID             int64
	DcNumber              string
	DcType                string
	Status                string
	TemplateID            sql.NullInt64
	BillToAddressID       sql.NullInt64
	ShipToAddressID       int64
	ChallanDate           sql.NullTime
	IssuedAt              sql.NullTime
	IssuedBy              sql.NullInt64
	CreatedBy             int64
	CreatedAt             sql.NullTime
	UpdatedAt             sql.NullTime
	BundleID              sql.NullInt64
	ShipmentGroupID       sql.NullInt64
	BillFromAddressID     sql.NullInt64
	DispatchFromAddressID sql.NullInt64
	TemplateName          sql.NullString
}

func (q *Queries) GetDeliveryChallanByID(ctx context.Context, id int64) (GetDeliveryChallanByIDRow, error) {
	row := q.db.QueryRowContext(ctx, GetDeliveryChallanByID, id)
	var i GetDeliveryChallanByIDRow
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.DcNumber,
		&i.DcType,
		&i.Status,
		&i.TemplateID,
		&i.BillToAddressID,
		&i.ShipToAddressID,
		&i.ChallanDate,
		&i.IssuedAt,
		&i.IssuedBy,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.BundleID,
		&i.ShipmentGroupID,
		&i.BillFromAddressID,
		&i.DispatchFromAddressID,
		&i.TemplateName,
	)
	return i, err
}

const GetLineItemsByDCID = `-- name: GetLineItemsByDCID :many
SELECT
    li.id, li.dc_id, li.product_id, li.quantity, li.rate, li.tax_percentage,
    li.taxable_amount, li.tax_amount, li.total_amount, li.line_order,
    li.created_at, li.updated_at,
    p.item_name, p.item_description, COALESCE(p.hsn_code, '') AS hsn_code,
    p.uom, COALESCE(p.brand_model, '') AS brand_model, p.gst_percentage
FROM dc_line_items li
INNER JOIN products p ON li.product_id = p.id
WHERE li.dc_id = ?
ORDER BY li.line_order
`

type GetLineItemsByDCIDRow struct {
	ID              int64
	DcID            int64
	ProductID       int64
	Quantity        int64
	Rate            sql.NullFloat64
	TaxPercentage   sql.NullFloat64
	TaxableAmount   sql.NullFloat64
	TaxAmount       sql.NullFloat64
	TotalAmount     sql.NullFloat64
	LineOrder       sql.NullInt64
	CreatedAt       sql.NullTime
	UpdatedAt       sql.NullTime
	ItemName        string
	ItemDescription string
	HsnCode         string
	Uom             sql.NullString
	BrandModel      string
	GstPercentage   sql.NullFloat64
}

func (q *Queries) GetLineItemsByDCID(ctx context.Context, dcID int64) ([]GetLineItemsByDCIDRow, error) {
	rows, err := q.db.QueryContext(ctx, GetLineItemsByDCID, dcID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLineItemsByDCIDRow{}
	for rows.Next() {
		var i GetLineItemsByDCIDRow
		if err := rows.Scan(
			&i.ID,
			&i.DcID,
			&i.ProductID,
			&i.Quantity,
			&i.Rate,
			&i.TaxPercentage,
			&i.TaxableAmount,
			&i.TaxAmount,
			&i.TotalAmount,
			&i.LineOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ItemName,
			&i.ItemDescription,
			&i.HsnCode,
			&i.Uom,
			&i.BrandModel,
			&i.GstPercentage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetSerialNumbersByLineItemID = `-- name: GetSerialNumbersByLineItemID :many
SELECT serial_number
FROM serial_numbers
WHERE line_item_id = ?
ORDER BY id
`

func (q *Queries) GetSerialNumbersByLineItemID(ctx context.Context, lineItemID int64) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, GetSerialNumbersByLineItemID, lineItemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var serial_number string
		if err := rows.Scan(&serial_number); err != nil {
			return nil, err
		}
		items = append(items, serial_number)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetTransitDetailsByDCID = `-- name: GetTransitDetailsByDCID :one
SELECT id, dc_id, transporter_name, vehicle_number, eway_bill_number, notes
FROM dc_transit_details
WHERE dc_id = ?
`

func (q *Queries) GetTransitDetailsByDCID(ctx context.Context, dcID int64) (DcTransitDetail, error) {
	row := q.db.QueryRowContext(ctx, GetTransitDetailsByDCID, dcID)
	var i DcTransitDetail
	err := row.Scan(
		&i.ID,
		&i.DcID,
		&i.TransporterName,
		&i.VehicleNumber,
		&i.EwayBillNumber,
		&i.Notes,
	)
	return i, err
}

const InsertDCLineItem = `-- name: InsertDCLineItem :execresult

INSERT INTO dc_line_items (
    dc_id, product_id, quantity, rate, tax_percentage,
    taxable_amount, tax_amount, total_amount, line_order
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type InsertDCLineItemParams struct {
	DcID          int64
	ProductID     int64
	Quantity      int64
	Rate          sql.NullFloat64
	TaxPercentage sql.NullFloat64
	TaxableAmount sql.NullFloat64
	TaxAmount     sql.NullFloat64
	TotalAmount   sql.NullFloat64
	LineOrder     sql.NullInt64
}

// =============================================================================
// DC Line Items
// =============================================================================
func (q *Queries) InsertDCLineItem(ctx context.Context, arg InsertDCLineItemParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, InsertDCLineItem,
		arg.DcID,
		arg.ProductID,
		arg.Quantity,
		arg.Rate,
		arg.TaxPercentage,
		arg.TaxableAmount,
		arg.TaxAmount,
		arg.TotalAmount,
		arg.LineOrder,
	)
}

const InsertDCTransitDetails = `-- name: InsertDCTransitDetails :exec

INSERT INTO dc_transit_details (dc_id, transporter_name, vehicle_number, eway_bill_number, notes)
VALUES (?, ?, ?, ?, ?)
`

type InsertDCTransitDetailsParams struct {
	DcID            int64
	TransporterName sql.NullString
	VehicleNumber   sql.NullString
	EwayBillNumber  sql.NullString
	Notes           sql.NullString
}

// =============================================================================
// DC Transit Details
// =============================================================================
func (q *Queries) InsertDCTransitDetails(ctx context.Context, arg InsertDCTransitDetailsParams) error {
	_, err := q.db.ExecContext(ctx, InsertDCTransitDetails,
		arg.DcID,
		arg.TransporterName,
		arg.VehicleNumber,
		arg.EwayBillNumber,
		arg.Notes,
	)
	return err
}

const InsertDeliveryChallan = `-- name: InsertDeliveryChallan :execresult


INSERT INTO delivery_challans (
    project_id, dc_number, dc_type, status, template_id,
    bill_to_address_id, ship_to_address_id, challan_date,
    created_by, shipment_group_id, bill_from_address_id, dispatch_from_address_id
) VALUES (
    ?, ?, ?, ?, ?,
    ?, ?, ?,
    ?, ?, ?, ?
)
`

type InsertDeliveryChallanParams struct {
	ProjectID             int64
	DcNumber              string
	DcType                string
	Status                string
	TemplateID            sql.NullInt64
	BillToAddressID       sql.NullInt64
	ShipToAddressID       int64
	ChallanDate           sql.NullTime
	CreatedBy             int64
	ShipmentGroupID       sql.NullInt64
	BillFromAddressID     sql.NullInt64
	DispatchFromAddressID sql.NullInt64
}

// delivery_challans.sql
// sqlc-annotated queries for delivery challans, transit details, line items, and serial numbers.
//
// NOTE: CreateDeliveryChallan, DeleteDC are transactions in Go code that wrap
// multiple INSERT/DELETE statements. The individual statements are extracted here
// as standalone sqlc queries. The transaction orchestration stays in Go.
//
// NOTE: CheckSerialsInProject and CheckSerialsInProjectByProduct accept a
// variable-length list of serial numbers via an IN clause built dynamically in Go.
// sqlc cannot statically analyse dynamic IN clauses. These functions must remain
// in hand-written Go. Representative single-serial variants are provided below for
// reference/documentation only (marked with a comment).
// =============================================================================
// Delivery Challans
// =============================================================================
func (q *Queries) InsertDeliveryChallan(ctx context.Context, arg InsertDeliveryChallanParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, InsertDeliveryChallan,
		arg.ProjectID,
		arg.DcNumber,
		arg.DcType,
		arg.Status,
		arg.TemplateID,
		arg.BillToAddressID,
		arg.ShipToAddressID,
		arg.ChallanDate,
		arg.CreatedBy,
		arg.ShipmentGroupID,
		arg.BillFromAddressID,
		arg.DispatchFromAddressID,
	)
}

const InsertSerialNumber = `-- name: InsertSerialNumber :exec

INSERT INTO serial_numbers (project_id, line_item_id, serial_number, product_id)
VALUES (?, ?, ?, ?)
`

type InsertSerialNumberParams struct {
	ProjectID    int64
	LineItemID   int64
	SerialNumber string
	ProductID    sql.NullInt64
}

// =============================================================================
// Serial Numbers
// =============================================================================
func (q *Queries) InsertSerialNumber(ctx context.Context, arg InsertSerialNumberParams) error {
	_, err := q.db.ExecContext(ctx, InsertSerialNumber,
		arg.ProjectID,
		arg.LineItemID,
		arg.SerialNumber,
		arg.ProductID,
	)
	return err
}

const IssueDC = `-- name: IssueDC :execresult
UPDATE delivery_challans
SET status     = 'issued',
    issued_at  = ?,
    issued_by  = ?,
    updated_at = ?
WHERE id     = ?
  AND status = 'draft'
`

type IssueDCParams struct {
	IssuedAt  sql.NullTime
	IssuedBy  sql.NullInt64
	UpdatedAt sql.NullTime
	ID        int64
}

func (q *Queries) IssueDC(ctx context.Context, arg IssueDCParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, IssueDC,
		arg.IssuedAt,
		arg.IssuedBy,
		arg.UpdatedAt,
		arg.ID,
	)
}
