// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: reports.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const GetDCSummaryOfficialDraft = `-- name: GetDCSummaryOfficialDraft :one
SELECT COUNT(*) AS official_draft_dcs
FROM delivery_challans dc
WHERE dc.project_id = ?
  AND dc.dc_type    = 'official'
  AND dc.status     = 'draft'
`

func (q *Queries) GetDCSummaryOfficialDraft(ctx context.Context, projectID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, GetDCSummaryOfficialDraft, projectID)
	var official_draft_dcs int64
	err := row.Scan(&official_draft_dcs)
	return official_draft_dcs, err
}

const GetDCSummaryOfficialDraftFiltered = `-- name: GetDCSummaryOfficialDraftFiltered :one
SELECT COUNT(*) AS official_draft_dcs
FROM delivery_challans dc
WHERE dc.project_id    = ?
  AND dc.dc_type       = 'official'
  AND dc.status        = 'draft'
  AND dc.challan_date >= ?
  AND dc.challan_date <= ?
`

type GetDCSummaryOfficialDraftFilteredParams struct {
	ProjectID     int64
	ChallanDate   sql.NullTime
	ChallanDate_2 sql.NullTime
}

func (q *Queries) GetDCSummaryOfficialDraftFiltered(ctx context.Context, arg GetDCSummaryOfficialDraftFilteredParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, GetDCSummaryOfficialDraftFiltered, arg.ProjectID, arg.ChallanDate, arg.ChallanDate_2)
	var official_draft_dcs int64
	err := row.Scan(&official_draft_dcs)
	return official_draft_dcs, err
}

const GetDCSummaryOfficialIssued = `-- name: GetDCSummaryOfficialIssued :one
SELECT COUNT(*) AS official_issued_dcs
FROM delivery_challans dc
WHERE dc.project_id = ?
  AND dc.dc_type    = 'official'
  AND dc.status     = 'issued'
`

func (q *Queries) GetDCSummaryOfficialIssued(ctx context.Context, projectID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, GetDCSummaryOfficialIssued, projectID)
	var official_issued_dcs int64
	err := row.Scan(&official_issued_dcs)
	return official_issued_dcs, err
}

const GetDCSummaryOfficialIssuedFiltered = `-- name: GetDCSummaryOfficialIssuedFiltered :one
SELECT COUNT(*) AS official_issued_dcs
FROM delivery_challans dc
WHERE dc.project_id    = ?
  AND dc.dc_type       = 'official'
  AND dc.status        = 'issued'
  AND dc.challan_date >= ?
  AND dc.challan_date <= ?
`

type GetDCSummaryOfficialIssuedFilteredParams struct {
	ProjectID     int64
	ChallanDate   sql.NullTime
	ChallanDate_2 sql.NullTime
}

func (q *Queries) GetDCSummaryOfficialIssuedFiltered(ctx context.Context, arg GetDCSummaryOfficialIssuedFilteredParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, GetDCSummaryOfficialIssuedFiltered, arg.ProjectID, arg.ChallanDate, arg.ChallanDate_2)
	var official_issued_dcs int64
	err := row.Scan(&official_issued_dcs)
	return official_issued_dcs, err
}

const GetDCSummaryTotalItemsDispatched = `-- name: GetDCSummaryTotalItemsDispatched :one
SELECT COALESCE(SUM(li.quantity), 0) AS total_items_dispatched
FROM dc_line_items li
INNER JOIN delivery_challans dc ON li.dc_id = dc.id
WHERE dc.project_id = ?
  AND dc.status     = 'issued'
`

func (q *Queries) GetDCSummaryTotalItemsDispatched(ctx context.Context, projectID int64) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, GetDCSummaryTotalItemsDispatched, projectID)
	var total_items_dispatched interface{}
	err := row.Scan(&total_items_dispatched)
	return total_items_dispatched, err
}

const GetDCSummaryTotalItemsDispatchedFiltered = `-- name: GetDCSummaryTotalItemsDispatchedFiltered :one
SELECT COALESCE(SUM(li.quantity), 0) AS total_items_dispatched
FROM dc_line_items li
INNER JOIN delivery_challans dc ON li.dc_id = dc.id
WHERE dc.project_id    = ?
  AND dc.status        = 'issued'
  AND dc.challan_date >= ?
  AND dc.challan_date <= ?
`

type GetDCSummaryTotalItemsDispatchedFilteredParams struct {
	ProjectID     int64
	ChallanDate   sql.NullTime
	ChallanDate_2 sql.NullTime
}

func (q *Queries) GetDCSummaryTotalItemsDispatchedFiltered(ctx context.Context, arg GetDCSummaryTotalItemsDispatchedFilteredParams) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, GetDCSummaryTotalItemsDispatchedFiltered, arg.ProjectID, arg.ChallanDate, arg.ChallanDate_2)
	var total_items_dispatched interface{}
	err := row.Scan(&total_items_dispatched)
	return total_items_dispatched, err
}

const GetDCSummaryTotalSerialsUsed = `-- name: GetDCSummaryTotalSerialsUsed :one
SELECT COUNT(*) AS total_serials_used
FROM serial_numbers sn
INNER JOIN dc_line_items li ON sn.line_item_id = li.id
INNER JOIN delivery_challans dc ON li.dc_id = dc.id
WHERE dc.project_id = ?
`

func (q *Queries) GetDCSummaryTotalSerialsUsed(ctx context.Context, projectID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, GetDCSummaryTotalSerialsUsed, projectID)
	var total_serials_used int64
	err := row.Scan(&total_serials_used)
	return total_serials_used, err
}

const GetDCSummaryTotalSerialsUsedFiltered = `-- name: GetDCSummaryTotalSerialsUsedFiltered :one
SELECT COUNT(*) AS total_serials_used
FROM serial_numbers sn
INNER JOIN dc_line_items li ON sn.line_item_id = li.id
INNER JOIN delivery_challans dc ON li.dc_id = dc.id
WHERE dc.project_id    = ?
  AND dc.challan_date >= ?
  AND dc.challan_date <= ?
`

type GetDCSummaryTotalSerialsUsedFilteredParams struct {
	ProjectID     int64
	ChallanDate   sql.NullTime
	ChallanDate_2 sql.NullTime
}

func (q *Queries) GetDCSummaryTotalSerialsUsedFiltered(ctx context.Context, arg GetDCSummaryTotalSerialsUsedFilteredParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, GetDCSummaryTotalSerialsUsedFiltered, arg.ProjectID, arg.ChallanDate, arg.ChallanDate_2)
	var total_serials_used int64
	err := row.Scan(&total_serials_used)
	return total_serials_used, err
}

const GetDCSummaryTransitDraft = `-- name: GetDCSummaryTransitDraft :one


SELECT COUNT(*) AS transit_draft_dcs
FROM delivery_challans dc
WHERE dc.project_id = ?
  AND dc.dc_type    = 'transit'
  AND dc.status     = 'draft'
`

// reports.sql
// sqlc-annotated queries for the reports module.
//
// NOTE: The Go helper dateFilterSQL() builds WHERE clauses dynamically based on
// whether startDate and/or endDate are non-nil. sqlc requires static SQL.
// Strategy:
//   - Unfiltered variant  - no date clause (suffix-less name)
//   - Date-filtered variant - both bounds present (suffix "Filtered")
//
// For single-bound date ranges (start-only or end-only), the hand-written Go
// queries in internal/database/reports.go remain appropriate.
//
// NOTE: GetSerialReport also accepts a variable-length comma-separated search
// string that builds a dynamic LIKE OR clause. That function stays in Go.
// A single-term LIKE variant is provided here for reference.
// =============================================================================
// DC Summary Report
// =============================================================================
func (q *Queries) GetDCSummaryTransitDraft(ctx context.Context, projectID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, GetDCSummaryTransitDraft, projectID)
	var transit_draft_dcs int64
	err := row.Scan(&transit_draft_dcs)
	return transit_draft_dcs, err
}

const GetDCSummaryTransitDraftFiltered = `-- name: GetDCSummaryTransitDraftFiltered :one
SELECT COUNT(*) AS transit_draft_dcs
FROM delivery_challans dc
WHERE dc.project_id    = ?
  AND dc.dc_type       = 'transit'
  AND dc.status        = 'draft'
  AND dc.challan_date >= ?
  AND dc.challan_date <= ?
`

type GetDCSummaryTransitDraftFilteredParams struct {
	ProjectID     int64
	ChallanDate   sql.NullTime
	ChallanDate_2 sql.NullTime
}

func (q *Queries) GetDCSummaryTransitDraftFiltered(ctx context.Context, arg GetDCSummaryTransitDraftFilteredParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, GetDCSummaryTransitDraftFiltered, arg.ProjectID, arg.ChallanDate, arg.ChallanDate_2)
	var transit_draft_dcs int64
	err := row.Scan(&transit_draft_dcs)
	return transit_draft_dcs, err
}

const GetDCSummaryTransitIssued = `-- name: GetDCSummaryTransitIssued :one
SELECT COUNT(*) AS transit_issued_dcs
FROM delivery_challans dc
WHERE dc.project_id = ?
  AND dc.dc_type    = 'transit'
  AND dc.status     = 'issued'
`

func (q *Queries) GetDCSummaryTransitIssued(ctx context.Context, projectID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, GetDCSummaryTransitIssued, projectID)
	var transit_issued_dcs int64
	err := row.Scan(&transit_issued_dcs)
	return transit_issued_dcs, err
}

const GetDCSummaryTransitIssuedFiltered = `-- name: GetDCSummaryTransitIssuedFiltered :one
SELECT COUNT(*) AS transit_issued_dcs
FROM delivery_challans dc
WHERE dc.project_id    = ?
  AND dc.dc_type       = 'transit'
  AND dc.status        = 'issued'
  AND dc.challan_date >= ?
  AND dc.challan_date <= ?
`

type GetDCSummaryTransitIssuedFilteredParams struct {
	ProjectID     int64
	ChallanDate   sql.NullTime
	ChallanDate_2 sql.NullTime
}

func (q *Queries) GetDCSummaryTransitIssuedFiltered(ctx context.Context, arg GetDCSummaryTransitIssuedFilteredParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, GetDCSummaryTransitIssuedFiltered, arg.ProjectID, arg.ChallanDate, arg.ChallanDate_2)
	var transit_issued_dcs int64
	err := row.Scan(&transit_issued_dcs)
	return transit_issued_dcs, err
}

const GetDestinationDCs = `-- name: GetDestinationDCs :many

SELECT
    dc.id,
    dc.dc_number,
    COALESCE(dc.challan_date, '') AS challan_date,
    dc.status,
    COALESCE(SUM(li.quantity), 0) AS total_items,
    dc.project_id
FROM delivery_challans dc
LEFT JOIN addresses a     ON dc.ship_to_address_id = a.id
LEFT JOIN dc_line_items li ON li.dc_id = dc.id
WHERE dc.project_id = ?
  AND dc.dc_type    = 'official'
  AND COALESCE(a.district_name, 'Unknown') = ?
  AND COALESCE(a.mandal_name,   'Unknown') = ?
GROUP BY dc.id
ORDER BY dc.challan_date DESC
`

type GetDestinationDCsParams struct {
	ProjectID    int64
	DistrictName string
	MandalName   string
}

type GetDestinationDCsRow struct {
	ID          int64
	DcNumber    string
	ChallanDate time.Time
	Status      string
	TotalItems  interface{}
	ProjectID   int64
}

// =============================================================================
// Destination Drill-Down
// =============================================================================
func (q *Queries) GetDestinationDCs(ctx context.Context, arg GetDestinationDCsParams) ([]GetDestinationDCsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetDestinationDCs, arg.ProjectID, arg.DistrictName, arg.MandalName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDestinationDCsRow{}
	for rows.Next() {
		var i GetDestinationDCsRow
		if err := rows.Scan(
			&i.ID,
			&i.DcNumber,
			&i.ChallanDate,
			&i.Status,
			&i.TotalItems,
			&i.ProjectID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetDestinationDCsFiltered = `-- name: GetDestinationDCsFiltered :many
SELECT
    dc.id,
    dc.dc_number,
    COALESCE(dc.challan_date, '') AS challan_date,
    dc.status,
    COALESCE(SUM(li.quantity), 0) AS total_items,
    dc.project_id
FROM delivery_challans dc
LEFT JOIN addresses a     ON dc.ship_to_address_id = a.id
LEFT JOIN dc_line_items li ON li.dc_id = dc.id
WHERE dc.project_id    = ?
  AND dc.dc_type       = 'official'
  AND COALESCE(a.district_name, 'Unknown') = ?
  AND COALESCE(a.mandal_name,   'Unknown') = ?
  AND dc.challan_date >= ?
  AND dc.challan_date <= ?
GROUP BY dc.id
ORDER BY dc.challan_date DESC
`

type GetDestinationDCsFilteredParams struct {
	ProjectID     int64
	DistrictName  string
	MandalName    string
	ChallanDate   sql.NullTime
	ChallanDate_2 sql.NullTime
}

type GetDestinationDCsFilteredRow struct {
	ID          int64
	DcNumber    string
	ChallanDate time.Time
	Status      string
	TotalItems  interface{}
	ProjectID   int64
}

func (q *Queries) GetDestinationDCsFiltered(ctx context.Context, arg GetDestinationDCsFilteredParams) ([]GetDestinationDCsFilteredRow, error) {
	rows, err := q.db.QueryContext(ctx, GetDestinationDCsFiltered,
		arg.ProjectID,
		arg.DistrictName,
		arg.MandalName,
		arg.ChallanDate,
		arg.ChallanDate_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDestinationDCsFilteredRow{}
	for rows.Next() {
		var i GetDestinationDCsFilteredRow
		if err := rows.Scan(
			&i.ID,
			&i.DcNumber,
			&i.ChallanDate,
			&i.Status,
			&i.TotalItems,
			&i.ProjectID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetDestinationReport = `-- name: GetDestinationReport :many

SELECT
    COALESCE(a.district_name, 'Unknown')  AS district,
    COALESCE(a.mandal_name,   'Unknown')  AS mandal,
    COUNT(CASE WHEN dc.dc_type = 'official' THEN 1 END)                       AS official_dcs,
    COALESCE(SUM(li_counts.total_qty), 0)                                     AS total_items,
    COUNT(CASE WHEN dc.dc_type = 'official' AND dc.status = 'draft'  THEN 1 END) AS draft_count,
    COUNT(CASE WHEN dc.dc_type = 'official' AND dc.status = 'issued' THEN 1 END) AS issued_count
FROM delivery_challans dc
LEFT JOIN addresses a ON dc.ship_to_address_id = a.id
LEFT JOIN (
    SELECT dc_id, SUM(quantity) AS total_qty
    FROM dc_line_items
    GROUP BY dc_id
) li_counts ON li_counts.dc_id = dc.id
WHERE dc.project_id = ?
GROUP BY COALESCE(a.district_name, 'Unknown'), COALESCE(a.mandal_name, 'Unknown')
ORDER BY district, mandal
`

type GetDestinationReportRow struct {
	District    string
	Mandal      string
	OfficialDcs int64
	TotalItems  interface{}
	DraftCount  int64
	IssuedCount int64
}

// =============================================================================
// Destination Report
// =============================================================================
func (q *Queries) GetDestinationReport(ctx context.Context, projectID int64) ([]GetDestinationReportRow, error) {
	rows, err := q.db.QueryContext(ctx, GetDestinationReport, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDestinationReportRow{}
	for rows.Next() {
		var i GetDestinationReportRow
		if err := rows.Scan(
			&i.District,
			&i.Mandal,
			&i.OfficialDcs,
			&i.TotalItems,
			&i.DraftCount,
			&i.IssuedCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetDestinationReportFiltered = `-- name: GetDestinationReportFiltered :many
SELECT
    COALESCE(a.district_name, 'Unknown')  AS district,
    COALESCE(a.mandal_name,   'Unknown')  AS mandal,
    COUNT(CASE WHEN dc.dc_type = 'official' THEN 1 END)                       AS official_dcs,
    COALESCE(SUM(li_counts.total_qty), 0)                                     AS total_items,
    COUNT(CASE WHEN dc.dc_type = 'official' AND dc.status = 'draft'  THEN 1 END) AS draft_count,
    COUNT(CASE WHEN dc.dc_type = 'official' AND dc.status = 'issued' THEN 1 END) AS issued_count
FROM delivery_challans dc
LEFT JOIN addresses a ON dc.ship_to_address_id = a.id
LEFT JOIN (
    SELECT dc_id, SUM(quantity) AS total_qty
    FROM dc_line_items
    GROUP BY dc_id
) li_counts ON li_counts.dc_id = dc.id
WHERE dc.project_id    = ?
  AND dc.challan_date >= ?
  AND dc.challan_date <= ?
GROUP BY COALESCE(a.district_name, 'Unknown'), COALESCE(a.mandal_name, 'Unknown')
ORDER BY district, mandal
`

type GetDestinationReportFilteredParams struct {
	ProjectID     int64
	ChallanDate   sql.NullTime
	ChallanDate_2 sql.NullTime
}

type GetDestinationReportFilteredRow struct {
	District    string
	Mandal      string
	OfficialDcs int64
	TotalItems  interface{}
	DraftCount  int64
	IssuedCount int64
}

func (q *Queries) GetDestinationReportFiltered(ctx context.Context, arg GetDestinationReportFilteredParams) ([]GetDestinationReportFilteredRow, error) {
	rows, err := q.db.QueryContext(ctx, GetDestinationReportFiltered, arg.ProjectID, arg.ChallanDate, arg.ChallanDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDestinationReportFilteredRow{}
	for rows.Next() {
		var i GetDestinationReportFilteredRow
		if err := rows.Scan(
			&i.District,
			&i.Mandal,
			&i.OfficialDcs,
			&i.TotalItems,
			&i.DraftCount,
			&i.IssuedCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetProductReport = `-- name: GetProductReport :many

SELECT
    COALESCE(p.item_name, 'Unknown')                                          AS product_name,
    COALESCE(SUM(li.quantity), 0)                                             AS total_qty,
    COUNT(DISTINCT dc.id)                                                     AS dc_count,
    COUNT(DISTINCT COALESCE(a.district_name, '') || '|' || COALESCE(a.mandal_name, '')) AS destination_count
FROM dc_line_items li
INNER JOIN delivery_challans dc ON li.dc_id = dc.id
LEFT JOIN products p            ON li.product_id = p.id
LEFT JOIN addresses a           ON dc.ship_to_address_id = a.id
WHERE dc.project_id = ?
GROUP BY li.product_id
ORDER BY total_qty DESC
`

type GetProductReportRow struct {
	ProductName      string
	TotalQty         interface{}
	DcCount          int64
	DestinationCount int64
}

// =============================================================================
// Product Report
// =============================================================================
func (q *Queries) GetProductReport(ctx context.Context, projectID int64) ([]GetProductReportRow, error) {
	rows, err := q.db.QueryContext(ctx, GetProductReport, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductReportRow{}
	for rows.Next() {
		var i GetProductReportRow
		if err := rows.Scan(
			&i.ProductName,
			&i.TotalQty,
			&i.DcCount,
			&i.DestinationCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetProductReportFiltered = `-- name: GetProductReportFiltered :many
SELECT
    COALESCE(p.item_name, 'Unknown')                                          AS product_name,
    COALESCE(SUM(li.quantity), 0)                                             AS total_qty,
    COUNT(DISTINCT dc.id)                                                     AS dc_count,
    COUNT(DISTINCT COALESCE(a.district_name, '') || '|' || COALESCE(a.mandal_name, '')) AS destination_count
FROM dc_line_items li
INNER JOIN delivery_challans dc ON li.dc_id = dc.id
LEFT JOIN products p            ON li.product_id = p.id
LEFT JOIN addresses a           ON dc.ship_to_address_id = a.id
WHERE dc.project_id    = ?
  AND dc.challan_date >= ?
  AND dc.challan_date <= ?
GROUP BY li.product_id
ORDER BY total_qty DESC
`

type GetProductReportFilteredParams struct {
	ProjectID     int64
	ChallanDate   sql.NullTime
	ChallanDate_2 sql.NullTime
}

type GetProductReportFilteredRow struct {
	ProductName      string
	TotalQty         interface{}
	DcCount          int64
	DestinationCount int64
}

func (q *Queries) GetProductReportFiltered(ctx context.Context, arg GetProductReportFilteredParams) ([]GetProductReportFilteredRow, error) {
	rows, err := q.db.QueryContext(ctx, GetProductReportFiltered, arg.ProjectID, arg.ChallanDate, arg.ChallanDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductReportFilteredRow{}
	for rows.Next() {
		var i GetProductReportFilteredRow
		if err := rows.Scan(
			&i.ProductName,
			&i.TotalQty,
			&i.DcCount,
			&i.DestinationCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetSerialReportNoSearch = `-- name: GetSerialReportNoSearch :many

SELECT
    sn.serial_number,
    COALESCE(p.item_name, 'Unknown')          AS product_name,
    dc.dc_number                              AS transit_dc_number,
    dc.id                                     AS transit_dc_id,
    COALESCE(dc.challan_date, '')             AS challan_date,
    COALESCE(td.vehicle_number, '')           AS vehicle_number,
    dc.project_id
FROM serial_numbers sn
INNER JOIN dc_line_items li        ON sn.line_item_id = li.id
INNER JOIN delivery_challans dc    ON li.dc_id        = dc.id
LEFT JOIN products p               ON li.product_id   = p.id
LEFT JOIN dc_transit_details td    ON td.dc_id        = dc.id
WHERE dc.project_id = ?
ORDER BY sn.serial_number
LIMIT 500
`

type GetSerialReportNoSearchRow struct {
	SerialNumber    string
	ProductName     string
	TransitDcNumber string
	TransitDcID     int64
	ChallanDate     time.Time
	VehicleNumber   string
	ProjectID       int64
}

// =============================================================================
// Serial Report
// NOTE: GetSerialReport in Go builds a dynamic LIKE OR clause for comma-separated
// search terms. That function stays in hand-written Go. The single-term variant
// below covers the common case of one search token and is usable via sqlc.
// =============================================================================
func (q *Queries) GetSerialReportNoSearch(ctx context.Context, projectID int64) ([]GetSerialReportNoSearchRow, error) {
	rows, err := q.db.QueryContext(ctx, GetSerialReportNoSearch, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSerialReportNoSearchRow{}
	for rows.Next() {
		var i GetSerialReportNoSearchRow
		if err := rows.Scan(
			&i.SerialNumber,
			&i.ProductName,
			&i.TransitDcNumber,
			&i.TransitDcID,
			&i.ChallanDate,
			&i.VehicleNumber,
			&i.ProjectID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetSerialReportNoSearchFiltered = `-- name: GetSerialReportNoSearchFiltered :many
SELECT
    sn.serial_number,
    COALESCE(p.item_name, 'Unknown')          AS product_name,
    dc.dc_number                              AS transit_dc_number,
    dc.id                                     AS transit_dc_id,
    COALESCE(dc.challan_date, '')             AS challan_date,
    COALESCE(td.vehicle_number, '')           AS vehicle_number,
    dc.project_id
FROM serial_numbers sn
INNER JOIN dc_line_items li        ON sn.line_item_id = li.id
INNER JOIN delivery_challans dc    ON li.dc_id        = dc.id
LEFT JOIN products p               ON li.product_id   = p.id
LEFT JOIN dc_transit_details td    ON td.dc_id        = dc.id
WHERE dc.project_id    = ?
  AND dc.challan_date >= ?
  AND dc.challan_date <= ?
ORDER BY sn.serial_number
LIMIT 500
`

type GetSerialReportNoSearchFilteredParams struct {
	ProjectID     int64
	ChallanDate   sql.NullTime
	ChallanDate_2 sql.NullTime
}

type GetSerialReportNoSearchFilteredRow struct {
	SerialNumber    string
	ProductName     string
	TransitDcNumber string
	TransitDcID     int64
	ChallanDate     time.Time
	VehicleNumber   string
	ProjectID       int64
}

func (q *Queries) GetSerialReportNoSearchFiltered(ctx context.Context, arg GetSerialReportNoSearchFilteredParams) ([]GetSerialReportNoSearchFilteredRow, error) {
	rows, err := q.db.QueryContext(ctx, GetSerialReportNoSearchFiltered, arg.ProjectID, arg.ChallanDate, arg.ChallanDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSerialReportNoSearchFilteredRow{}
	for rows.Next() {
		var i GetSerialReportNoSearchFilteredRow
		if err := rows.Scan(
			&i.SerialNumber,
			&i.ProductName,
			&i.TransitDcNumber,
			&i.TransitDcID,
			&i.ChallanDate,
			&i.VehicleNumber,
			&i.ProjectID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetSerialReportSingleSearch = `-- name: GetSerialReportSingleSearch :many
SELECT
    sn.serial_number,
    COALESCE(p.item_name, 'Unknown')          AS product_name,
    dc.dc_number                              AS transit_dc_number,
    dc.id                                     AS transit_dc_id,
    COALESCE(dc.challan_date, '')             AS challan_date,
    COALESCE(td.vehicle_number, '')           AS vehicle_number,
    dc.project_id
FROM serial_numbers sn
INNER JOIN dc_line_items li        ON sn.line_item_id = li.id
INNER JOIN delivery_challans dc    ON li.dc_id        = dc.id
LEFT JOIN products p               ON li.product_id   = p.id
LEFT JOIN dc_transit_details td    ON td.dc_id        = dc.id
WHERE dc.project_id          = ?
  AND sn.serial_number LIKE  ?
ORDER BY sn.serial_number
LIMIT 500
`

type GetSerialReportSingleSearchParams struct {
	ProjectID    int64
	SerialNumber string
}

type GetSerialReportSingleSearchRow struct {
	SerialNumber    string
	ProductName     string
	TransitDcNumber string
	TransitDcID     int64
	ChallanDate     time.Time
	VehicleNumber   string
	ProjectID       int64
}

// Single search term variant (LIKE). Multi-term variant stays in hand-written Go.
func (q *Queries) GetSerialReportSingleSearch(ctx context.Context, arg GetSerialReportSingleSearchParams) ([]GetSerialReportSingleSearchRow, error) {
	rows, err := q.db.QueryContext(ctx, GetSerialReportSingleSearch, arg.ProjectID, arg.SerialNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSerialReportSingleSearchRow{}
	for rows.Next() {
		var i GetSerialReportSingleSearchRow
		if err := rows.Scan(
			&i.SerialNumber,
			&i.ProductName,
			&i.TransitDcNumber,
			&i.TransitDcID,
			&i.ChallanDate,
			&i.VehicleNumber,
			&i.ProjectID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetSerialReportSingleSearchFiltered = `-- name: GetSerialReportSingleSearchFiltered :many
SELECT
    sn.serial_number,
    COALESCE(p.item_name, 'Unknown')          AS product_name,
    dc.dc_number                              AS transit_dc_number,
    dc.id                                     AS transit_dc_id,
    COALESCE(dc.challan_date, '')             AS challan_date,
    COALESCE(td.vehicle_number, '')           AS vehicle_number,
    dc.project_id
FROM serial_numbers sn
INNER JOIN dc_line_items li        ON sn.line_item_id = li.id
INNER JOIN delivery_challans dc    ON li.dc_id        = dc.id
LEFT JOIN products p               ON li.product_id   = p.id
LEFT JOIN dc_transit_details td    ON td.dc_id        = dc.id
WHERE dc.project_id          = ?
  AND dc.challan_date        >= ?
  AND dc.challan_date        <= ?
  AND sn.serial_number LIKE  ?
ORDER BY sn.serial_number
LIMIT 500
`

type GetSerialReportSingleSearchFilteredParams struct {
	ProjectID     int64
	ChallanDate   sql.NullTime
	ChallanDate_2 sql.NullTime
	SerialNumber  string
}

type GetSerialReportSingleSearchFilteredRow struct {
	SerialNumber    string
	ProductName     string
	TransitDcNumber string
	TransitDcID     int64
	ChallanDate     time.Time
	VehicleNumber   string
	ProjectID       int64
}

// Single search term + date range variant.
func (q *Queries) GetSerialReportSingleSearchFiltered(ctx context.Context, arg GetSerialReportSingleSearchFilteredParams) ([]GetSerialReportSingleSearchFilteredRow, error) {
	rows, err := q.db.QueryContext(ctx, GetSerialReportSingleSearchFiltered,
		arg.ProjectID,
		arg.ChallanDate,
		arg.ChallanDate_2,
		arg.SerialNumber,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSerialReportSingleSearchFilteredRow{}
	for rows.Next() {
		var i GetSerialReportSingleSearchFilteredRow
		if err := rows.Scan(
			&i.SerialNumber,
			&i.ProductName,
			&i.TransitDcNumber,
			&i.TransitDcID,
			&i.ChallanDate,
			&i.VehicleNumber,
			&i.ProjectID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
