// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: addresses.sql

package db

import (
	"context"
	"database/sql"
)

const CountAddresses = `-- name: CountAddresses :one
SELECT COUNT(*) FROM addresses WHERE config_id = ?
`

func (q *Queries) CountAddresses(ctx context.Context, configID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountAddresses, configID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountAddressesWithSearch = `-- name: CountAddressesWithSearch :one
SELECT COUNT(*) FROM addresses
WHERE config_id = ?
  AND (address_data LIKE ? OR district_name LIKE ? OR mandal_name LIKE ? OR mandal_code LIKE ?)
`

type CountAddressesWithSearchParams struct {
	ConfigID     int64
	AddressData  string
	DistrictName string
	MandalName   string
	MandalCode   string
}

func (q *Queries) CountAddressesWithSearch(ctx context.Context, arg CountAddressesWithSearchParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountAddressesWithSearch,
		arg.ConfigID,
		arg.AddressData,
		arg.DistrictName,
		arg.MandalName,
		arg.MandalCode,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateAddressConfig = `-- name: CreateAddressConfig :execresult
INSERT INTO address_list_configs (project_id, address_type, column_definitions)
VALUES (?, ?, ?)
`

type CreateAddressConfigParams struct {
	ProjectID         int64
	AddressType       string
	ColumnDefinitions string
}

func (q *Queries) CreateAddressConfig(ctx context.Context, arg CreateAddressConfigParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, CreateAddressConfig, arg.ProjectID, arg.AddressType, arg.ColumnDefinitions)
}

const DeleteAddress = `-- name: DeleteAddress :exec
DELETE FROM addresses WHERE id = ? AND config_id = ?
`

type DeleteAddressParams struct {
	ID       int64
	ConfigID int64
}

func (q *Queries) DeleteAddress(ctx context.Context, arg DeleteAddressParams) error {
	_, err := q.db.ExecContext(ctx, DeleteAddress, arg.ID, arg.ConfigID)
	return err
}

const DeleteAllAddresses = `-- name: DeleteAllAddresses :exec
DELETE FROM addresses WHERE config_id = ?
`

func (q *Queries) DeleteAllAddresses(ctx context.Context, configID int64) error {
	_, err := q.db.ExecContext(ctx, DeleteAllAddresses, configID)
	return err
}

const GetAddress = `-- name: GetAddress :one
SELECT id, config_id, address_data, district_name, mandal_name, mandal_code, created_at, updated_at
FROM addresses
WHERE id = ?
`

type GetAddressRow struct {
	ID           int64
	ConfigID     int64
	AddressData  string
	DistrictName string
	MandalName   string
	MandalCode   string
	CreatedAt    sql.NullTime
	UpdatedAt    sql.NullTime
}

func (q *Queries) GetAddress(ctx context.Context, id int64) (GetAddressRow, error) {
	row := q.db.QueryRowContext(ctx, GetAddress, id)
	var i GetAddressRow
	err := row.Scan(
		&i.ID,
		&i.ConfigID,
		&i.AddressData,
		&i.DistrictName,
		&i.MandalName,
		&i.MandalCode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetAddressConfig = `-- name: GetAddressConfig :one
SELECT id, project_id, address_type, column_definitions, created_at, updated_at
FROM address_list_configs
WHERE project_id = ? AND address_type = ?
`

type GetAddressConfigParams struct {
	ProjectID   int64
	AddressType string
}

func (q *Queries) GetAddressConfig(ctx context.Context, arg GetAddressConfigParams) (AddressListConfig, error) {
	row := q.db.QueryRowContext(ctx, GetAddressConfig, arg.ProjectID, arg.AddressType)
	var i AddressListConfig
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.AddressType,
		&i.ColumnDefinitions,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const InsertAddress = `-- name: InsertAddress :execresult
INSERT INTO addresses (config_id, address_data, district_name, mandal_name, mandal_code)
VALUES (?, ?, ?, ?, ?)
`

type InsertAddressParams struct {
	ConfigID     int64
	AddressData  string
	DistrictName string
	MandalName   string
	MandalCode   string
}

func (q *Queries) InsertAddress(ctx context.Context, arg InsertAddressParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, InsertAddress,
		arg.ConfigID,
		arg.AddressData,
		arg.DistrictName,
		arg.MandalName,
		arg.MandalCode,
	)
}

const ListAddresses = `-- name: ListAddresses :many
SELECT id, config_id, address_data, district_name, mandal_name, mandal_code, created_at, updated_at
FROM addresses
WHERE config_id = ?
ORDER BY id DESC
LIMIT ? OFFSET ?
`

type ListAddressesParams struct {
	ConfigID int64
	Limit    int64
	Offset   int64
}

type ListAddressesRow struct {
	ID           int64
	ConfigID     int64
	AddressData  string
	DistrictName string
	MandalName   string
	MandalCode   string
	CreatedAt    sql.NullTime
	UpdatedAt    sql.NullTime
}

func (q *Queries) ListAddresses(ctx context.Context, arg ListAddressesParams) ([]ListAddressesRow, error) {
	rows, err := q.db.QueryContext(ctx, ListAddresses, arg.ConfigID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAddressesRow{}
	for rows.Next() {
		var i ListAddressesRow
		if err := rows.Scan(
			&i.ID,
			&i.ConfigID,
			&i.AddressData,
			&i.DistrictName,
			&i.MandalName,
			&i.MandalCode,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListAddressesWithSearch = `-- name: ListAddressesWithSearch :many
SELECT id, config_id, address_data, district_name, mandal_name, mandal_code, created_at, updated_at
FROM addresses
WHERE config_id = ?
  AND (address_data LIKE ? OR district_name LIKE ? OR mandal_name LIKE ? OR mandal_code LIKE ?)
ORDER BY id DESC
LIMIT ? OFFSET ?
`

type ListAddressesWithSearchParams struct {
	ConfigID     int64
	AddressData  string
	DistrictName string
	MandalName   string
	MandalCode   string
	Limit        int64
	Offset       int64
}

type ListAddressesWithSearchRow struct {
	ID           int64
	ConfigID     int64
	AddressData  string
	DistrictName string
	MandalName   string
	MandalCode   string
	CreatedAt    sql.NullTime
	UpdatedAt    sql.NullTime
}

func (q *Queries) ListAddressesWithSearch(ctx context.Context, arg ListAddressesWithSearchParams) ([]ListAddressesWithSearchRow, error) {
	rows, err := q.db.QueryContext(ctx, ListAddressesWithSearch,
		arg.ConfigID,
		arg.AddressData,
		arg.DistrictName,
		arg.MandalName,
		arg.MandalCode,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAddressesWithSearchRow{}
	for rows.Next() {
		var i ListAddressesWithSearchRow
		if err := rows.Scan(
			&i.ID,
			&i.ConfigID,
			&i.AddressData,
			&i.DistrictName,
			&i.MandalName,
			&i.MandalCode,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchAddressesForSelector = `-- name: SearchAddressesForSelector :many
SELECT id, config_id, address_data, district_name, mandal_name, mandal_code, created_at, updated_at
FROM addresses
WHERE config_id = ?
  AND (address_data LIKE ? OR district_name LIKE ? OR mandal_name LIKE ? OR mandal_code LIKE ?)
ORDER BY district_name, mandal_name
LIMIT ?
`

type SearchAddressesForSelectorParams struct {
	ConfigID     int64
	AddressData  string
	DistrictName string
	MandalName   string
	MandalCode   string
	Limit        int64
}

type SearchAddressesForSelectorRow struct {
	ID           int64
	ConfigID     int64
	AddressData  string
	DistrictName string
	MandalName   string
	MandalCode   string
	CreatedAt    sql.NullTime
	UpdatedAt    sql.NullTime
}

func (q *Queries) SearchAddressesForSelector(ctx context.Context, arg SearchAddressesForSelectorParams) ([]SearchAddressesForSelectorRow, error) {
	rows, err := q.db.QueryContext(ctx, SearchAddressesForSelector,
		arg.ConfigID,
		arg.AddressData,
		arg.DistrictName,
		arg.MandalName,
		arg.MandalCode,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchAddressesForSelectorRow{}
	for rows.Next() {
		var i SearchAddressesForSelectorRow
		if err := rows.Scan(
			&i.ID,
			&i.ConfigID,
			&i.AddressData,
			&i.DistrictName,
			&i.MandalName,
			&i.MandalCode,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchAddressesForSelectorSimple = `-- name: SearchAddressesForSelectorSimple :many
SELECT id, config_id, address_data, district_name, mandal_name, mandal_code, created_at, updated_at
FROM addresses
WHERE config_id = ? AND address_data LIKE ?
ORDER BY id
LIMIT ?
`

type SearchAddressesForSelectorSimpleParams struct {
	ConfigID    int64
	AddressData string
	Limit       int64
}

type SearchAddressesForSelectorSimpleRow struct {
	ID           int64
	ConfigID     int64
	AddressData  string
	DistrictName string
	MandalName   string
	MandalCode   string
	CreatedAt    sql.NullTime
	UpdatedAt    sql.NullTime
}

func (q *Queries) SearchAddressesForSelectorSimple(ctx context.Context, arg SearchAddressesForSelectorSimpleParams) ([]SearchAddressesForSelectorSimpleRow, error) {
	rows, err := q.db.QueryContext(ctx, SearchAddressesForSelectorSimple, arg.ConfigID, arg.AddressData, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchAddressesForSelectorSimpleRow{}
	for rows.Next() {
		var i SearchAddressesForSelectorSimpleRow
		if err := rows.Scan(
			&i.ID,
			&i.ConfigID,
			&i.AddressData,
			&i.DistrictName,
			&i.MandalName,
			&i.MandalCode,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchAddressesNoFilter = `-- name: SearchAddressesNoFilter :many
SELECT id, config_id, address_data, district_name, mandal_name, mandal_code, created_at, updated_at
FROM addresses
WHERE config_id = ?
ORDER BY id
LIMIT ?
`

type SearchAddressesNoFilterParams struct {
	ConfigID int64
	Limit    int64
}

type SearchAddressesNoFilterRow struct {
	ID           int64
	ConfigID     int64
	AddressData  string
	DistrictName string
	MandalName   string
	MandalCode   string
	CreatedAt    sql.NullTime
	UpdatedAt    sql.NullTime
}

func (q *Queries) SearchAddressesNoFilter(ctx context.Context, arg SearchAddressesNoFilterParams) ([]SearchAddressesNoFilterRow, error) {
	rows, err := q.db.QueryContext(ctx, SearchAddressesNoFilter, arg.ConfigID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchAddressesNoFilterRow{}
	for rows.Next() {
		var i SearchAddressesNoFilterRow
		if err := rows.Scan(
			&i.ID,
			&i.ConfigID,
			&i.AddressData,
			&i.DistrictName,
			&i.MandalName,
			&i.MandalCode,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateAddress = `-- name: UpdateAddress :exec
UPDATE addresses SET address_data = ?, district_name = ?, mandal_name = ?, mandal_code = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateAddressParams struct {
	AddressData  string
	DistrictName string
	MandalName   string
	MandalCode   string
	ID           int64
}

func (q *Queries) UpdateAddress(ctx context.Context, arg UpdateAddressParams) error {
	_, err := q.db.ExecContext(ctx, UpdateAddress,
		arg.AddressData,
		arg.DistrictName,
		arg.MandalName,
		arg.MandalCode,
		arg.ID,
	)
	return err
}

const UpdateAddressConfig = `-- name: UpdateAddressConfig :exec
UPDATE address_list_configs SET column_definitions = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateAddressConfigParams struct {
	ColumnDefinitions string
	ID                int64
}

func (q *Queries) UpdateAddressConfig(ctx context.Context, arg UpdateAddressConfigParams) error {
	_, err := q.db.ExecContext(ctx, UpdateAddressConfig, arg.ColumnDefinitions, arg.ID)
	return err
}
