// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: serial_search.sql

package db

import (
	"context"
	"time"
)

const SearchSerialsSingleTermAllProjects = `-- name: SearchSerialsSingleTermAllProjects :many


SELECT
    sn.serial_number,
    dc.dc_number,
    dc.id                                    AS dc_id,
    dc.dc_type,
    dc.project_id,
    COALESCE(p.name,       'Unknown')        AS project_name,
    COALESCE(pr.item_name, 'Unknown')        AS product_name,
    COALESCE(dc.challan_date, '')            AS challan_date,
    COALESCE(
        (
            SELECT GROUP_CONCAT(val, ', ')
            FROM (
                SELECT json_each.value AS val
                FROM addresses a2, json_each(a2.address_data)
                WHERE a2.id = dc.ship_to_address_id
                LIMIT 2
            )
        ),
        'N/A'
    )                                        AS ship_to_summary,
    dc.status
FROM serial_numbers sn
INNER JOIN dc_line_items li        ON sn.line_item_id = li.id
INNER JOIN delivery_challans dc    ON li.dc_id        = dc.id
LEFT JOIN products pr              ON li.product_id   = pr.id
LEFT JOIN projects p               ON dc.project_id   = p.id
WHERE sn.serial_number LIKE ?
ORDER BY dc.challan_date DESC, sn.serial_number ASC
LIMIT 200
`

type SearchSerialsSingleTermAllProjectsRow struct {
	SerialNumber  string
	DcNumber      string
	DcID          int64
	DcType        string
	ProjectID     int64
	ProjectName   string
	ProductName   string
	ChallanDate   time.Time
	ShipToSummary interface{}
	Status        string
}

// serial_search.sql
// sqlc-annotated queries for the global serial number search feature.
//
// NOTE: SearchSerialNumbers in Go parses a comma/newline-separated query string
// into individual tokens and builds a dynamic WHERE clause with one LIKE condition
// per token joined with OR:
//
//	WHERE (sn.serial_number LIKE ? OR sn.serial_number LIKE ? OR ...)
//	  AND dc.project_id = ?        -- optional, only when projectID != "" && != "all"
//
// sqlc cannot statically analyse this pattern. The full hand-written implementation
// in internal/database/serial_search.go must remain unchanged.
//
// The queries below cover the statically-expressible cases:
//  1. Single search token, all projects
//  2. Single search token, specific project
//  3. Two search tokens, all projects     (demonstrates :many with fixed arity)
//  4. Two search tokens, specific project
//
// For production use the Go function is preferred; these variants exist so that
// sqlc can generate useful helper types (SerialSearchResult row struct) and so
// that the canonical SQL is documented and version-controlled.
// =============================================================================
// Single token - all projects
// =============================================================================
func (q *Queries) SearchSerialsSingleTermAllProjects(ctx context.Context, serialNumber string) ([]SearchSerialsSingleTermAllProjectsRow, error) {
	rows, err := q.db.QueryContext(ctx, SearchSerialsSingleTermAllProjects, serialNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchSerialsSingleTermAllProjectsRow{}
	for rows.Next() {
		var i SearchSerialsSingleTermAllProjectsRow
		if err := rows.Scan(
			&i.SerialNumber,
			&i.DcNumber,
			&i.DcID,
			&i.DcType,
			&i.ProjectID,
			&i.ProjectName,
			&i.ProductName,
			&i.ChallanDate,
			&i.ShipToSummary,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchSerialsSingleTermByProject = `-- name: SearchSerialsSingleTermByProject :many

SELECT
    sn.serial_number,
    dc.dc_number,
    dc.id                                    AS dc_id,
    dc.dc_type,
    dc.project_id,
    COALESCE(p.name,       'Unknown')        AS project_name,
    COALESCE(pr.item_name, 'Unknown')        AS product_name,
    COALESCE(dc.challan_date, '')            AS challan_date,
    COALESCE(
        (
            SELECT GROUP_CONCAT(val, ', ')
            FROM (
                SELECT json_each.value AS val
                FROM addresses a2, json_each(a2.address_data)
                WHERE a2.id = dc.ship_to_address_id
                LIMIT 2
            )
        ),
        'N/A'
    )                                        AS ship_to_summary,
    dc.status
FROM serial_numbers sn
INNER JOIN dc_line_items li        ON sn.line_item_id = li.id
INNER JOIN delivery_challans dc    ON li.dc_id        = dc.id
LEFT JOIN products pr              ON li.product_id   = pr.id
LEFT JOIN projects p               ON dc.project_id   = p.id
WHERE sn.serial_number LIKE ?
  AND dc.project_id = ?
ORDER BY dc.challan_date DESC, sn.serial_number ASC
LIMIT 200
`

type SearchSerialsSingleTermByProjectParams struct {
	SerialNumber string
	ProjectID    int64
}

type SearchSerialsSingleTermByProjectRow struct {
	SerialNumber  string
	DcNumber      string
	DcID          int64
	DcType        string
	ProjectID     int64
	ProjectName   string
	ProductName   string
	ChallanDate   time.Time
	ShipToSummary interface{}
	Status        string
}

// =============================================================================
// Single token - scoped to one project
// =============================================================================
func (q *Queries) SearchSerialsSingleTermByProject(ctx context.Context, arg SearchSerialsSingleTermByProjectParams) ([]SearchSerialsSingleTermByProjectRow, error) {
	rows, err := q.db.QueryContext(ctx, SearchSerialsSingleTermByProject, arg.SerialNumber, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchSerialsSingleTermByProjectRow{}
	for rows.Next() {
		var i SearchSerialsSingleTermByProjectRow
		if err := rows.Scan(
			&i.SerialNumber,
			&i.DcNumber,
			&i.DcID,
			&i.DcType,
			&i.ProjectID,
			&i.ProjectName,
			&i.ProductName,
			&i.ChallanDate,
			&i.ShipToSummary,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchSerialsTwoTermsAllProjects = `-- name: SearchSerialsTwoTermsAllProjects :many

SELECT
    sn.serial_number,
    dc.dc_number,
    dc.id                                    AS dc_id,
    dc.dc_type,
    dc.project_id,
    COALESCE(p.name,       'Unknown')        AS project_name,
    COALESCE(pr.item_name, 'Unknown')        AS product_name,
    COALESCE(dc.challan_date, '')            AS challan_date,
    COALESCE(
        (
            SELECT GROUP_CONCAT(val, ', ')
            FROM (
                SELECT json_each.value AS val
                FROM addresses a2, json_each(a2.address_data)
                WHERE a2.id = dc.ship_to_address_id
                LIMIT 2
            )
        ),
        'N/A'
    )                                        AS ship_to_summary,
    dc.status
FROM serial_numbers sn
INNER JOIN dc_line_items li        ON sn.line_item_id = li.id
INNER JOIN delivery_challans dc    ON li.dc_id        = dc.id
LEFT JOIN products pr              ON li.product_id   = pr.id
LEFT JOIN projects p               ON dc.project_id   = p.id
WHERE (sn.serial_number LIKE ? OR sn.serial_number LIKE ?)
ORDER BY dc.challan_date DESC, sn.serial_number ASC
LIMIT 200
`

type SearchSerialsTwoTermsAllProjectsParams struct {
	SerialNumber   string
	SerialNumber_2 string
}

type SearchSerialsTwoTermsAllProjectsRow struct {
	SerialNumber  string
	DcNumber      string
	DcID          int64
	DcType        string
	ProjectID     int64
	ProjectName   string
	ProductName   string
	ChallanDate   time.Time
	ShipToSummary interface{}
	Status        string
}

// =============================================================================
// Two tokens - all projects
// (Illustrates fixed-arity OR expansion; Go handles arbitrary arity.)
// =============================================================================
func (q *Queries) SearchSerialsTwoTermsAllProjects(ctx context.Context, arg SearchSerialsTwoTermsAllProjectsParams) ([]SearchSerialsTwoTermsAllProjectsRow, error) {
	rows, err := q.db.QueryContext(ctx, SearchSerialsTwoTermsAllProjects, arg.SerialNumber, arg.SerialNumber_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchSerialsTwoTermsAllProjectsRow{}
	for rows.Next() {
		var i SearchSerialsTwoTermsAllProjectsRow
		if err := rows.Scan(
			&i.SerialNumber,
			&i.DcNumber,
			&i.DcID,
			&i.DcType,
			&i.ProjectID,
			&i.ProjectName,
			&i.ProductName,
			&i.ChallanDate,
			&i.ShipToSummary,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchSerialsTwoTermsByProject = `-- name: SearchSerialsTwoTermsByProject :many

SELECT
    sn.serial_number,
    dc.dc_number,
    dc.id                                    AS dc_id,
    dc.dc_type,
    dc.project_id,
    COALESCE(p.name,       'Unknown')        AS project_name,
    COALESCE(pr.item_name, 'Unknown')        AS product_name,
    COALESCE(dc.challan_date, '')            AS challan_date,
    COALESCE(
        (
            SELECT GROUP_CONCAT(val, ', ')
            FROM (
                SELECT json_each.value AS val
                FROM addresses a2, json_each(a2.address_data)
                WHERE a2.id = dc.ship_to_address_id
                LIMIT 2
            )
        ),
        'N/A'
    )                                        AS ship_to_summary,
    dc.status
FROM serial_numbers sn
INNER JOIN dc_line_items li        ON sn.line_item_id = li.id
INNER JOIN delivery_challans dc    ON li.dc_id        = dc.id
LEFT JOIN products pr              ON li.product_id   = pr.id
LEFT JOIN projects p               ON dc.project_id   = p.id
WHERE (sn.serial_number LIKE ? OR sn.serial_number LIKE ?)
  AND dc.project_id = ?
ORDER BY dc.challan_date DESC, sn.serial_number ASC
LIMIT 200
`

type SearchSerialsTwoTermsByProjectParams struct {
	SerialNumber   string
	SerialNumber_2 string
	ProjectID      int64
}

type SearchSerialsTwoTermsByProjectRow struct {
	SerialNumber  string
	DcNumber      string
	DcID          int64
	DcType        string
	ProjectID     int64
	ProjectName   string
	ProductName   string
	ChallanDate   time.Time
	ShipToSummary interface{}
	Status        string
}

// =============================================================================
// Two tokens - scoped to one project
// =============================================================================
func (q *Queries) SearchSerialsTwoTermsByProject(ctx context.Context, arg SearchSerialsTwoTermsByProjectParams) ([]SearchSerialsTwoTermsByProjectRow, error) {
	rows, err := q.db.QueryContext(ctx, SearchSerialsTwoTermsByProject, arg.SerialNumber, arg.SerialNumber_2, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchSerialsTwoTermsByProjectRow{}
	for rows.Next() {
		var i SearchSerialsTwoTermsByProjectRow
		if err := rows.Scan(
			&i.SerialNumber,
			&i.DcNumber,
			&i.DcID,
			&i.DcType,
			&i.ProjectID,
			&i.ProjectName,
			&i.ProductName,
			&i.ChallanDate,
			&i.ShipToSummary,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
