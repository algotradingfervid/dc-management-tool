// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: dc_listing.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const CountAllDCsFiltered = `-- name: CountAllDCsFiltered :one
SELECT COUNT(*)
FROM delivery_challans dc
`

// Dynamic filters are applied in Go; this base query is used when no filters are set.
// The actual runtime query is built dynamically in GetAllDCsFiltered.
func (q *Queries) CountAllDCsFiltered(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountAllDCsFiltered)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountAllDCsFilteredByDateRange = `-- name: CountAllDCsFilteredByDateRange :one
SELECT COUNT(*)
FROM delivery_challans dc
WHERE dc.challan_date >= ? AND dc.challan_date <= ?
`

type CountAllDCsFilteredByDateRangeParams struct {
	ChallanDate   sql.NullTime
	ChallanDate_2 sql.NullTime
}

func (q *Queries) CountAllDCsFilteredByDateRange(ctx context.Context, arg CountAllDCsFilteredByDateRangeParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountAllDCsFilteredByDateRange, arg.ChallanDate, arg.ChallanDate_2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountAllDCsFilteredByProject = `-- name: CountAllDCsFilteredByProject :one
SELECT COUNT(*)
FROM delivery_challans dc
WHERE dc.project_id = ?
`

func (q *Queries) CountAllDCsFilteredByProject(ctx context.Context, projectID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountAllDCsFilteredByProject, projectID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountAllDCsFilteredBySearch = `-- name: CountAllDCsFilteredBySearch :one
SELECT COUNT(*)
FROM delivery_challans dc
WHERE dc.dc_number LIKE ?
`

func (q *Queries) CountAllDCsFilteredBySearch(ctx context.Context, dcNumber string) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountAllDCsFilteredBySearch, dcNumber)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountAllDCsFilteredByStatus = `-- name: CountAllDCsFilteredByStatus :one
SELECT COUNT(*)
FROM delivery_challans dc
WHERE dc.status = ?
`

func (q *Queries) CountAllDCsFilteredByStatus(ctx context.Context, status string) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountAllDCsFilteredByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountAllDCsFilteredByType = `-- name: CountAllDCsFilteredByType :one
SELECT COUNT(*)
FROM delivery_challans dc
WHERE dc.dc_type = ?
`

func (q *Queries) CountAllDCsFilteredByType(ctx context.Context, dcType string) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountAllDCsFilteredByType, dcType)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const GetAllDCsPaginated = `-- name: GetAllDCsPaginated :many
SELECT
    dc.id,
    dc.dc_number,
    dc.dc_type,
    COALESCE(dc.challan_date, '') AS challan_date,
    dc.project_id,
    COALESCE(p.name, 'Unknown') AS project_name,
    COALESCE(
        (
            SELECT GROUP_CONCAT(val, ', ')
            FROM (
                SELECT json_each.value AS val
                FROM addresses a2, json_each(a2.address_data)
                WHERE a2.id = dc.ship_to_address_id
                LIMIT 2
            )
        ),
        'N/A'
    ) AS ship_to_summary,
    dc.status,
    (SELECT SUM(li.total_amount) FROM dc_line_items li WHERE li.dc_id = dc.id) AS total_value,
    (SELECT COUNT(*) FROM dc_line_items li WHERE li.dc_id = dc.id) AS line_item_count,
    (SELECT COALESCE(SUM(li.quantity), 0) FROM dc_line_items li WHERE li.dc_id = dc.id) AS total_quantity
FROM delivery_challans dc
LEFT JOIN projects p ON dc.project_id = p.id
ORDER BY dc.challan_date DESC
LIMIT ? OFFSET ?
`

type GetAllDCsPaginatedParams struct {
	Limit  int64
	Offset int64
}

type GetAllDCsPaginatedRow struct {
	ID            int64
	DcNumber      string
	DcType        string
	ChallanDate   time.Time
	ProjectID     int64
	ProjectName   string
	ShipToSummary interface{}
	Status        string
	TotalValue    sql.NullFloat64
	LineItemCount int64
	TotalQuantity interface{}
}

// Base paginated listing with project join; dynamic filters applied in Go.
// The actual runtime query is built dynamically in GetAllDCsFiltered.
func (q *Queries) GetAllDCsPaginated(ctx context.Context, arg GetAllDCsPaginatedParams) ([]GetAllDCsPaginatedRow, error) {
	rows, err := q.db.QueryContext(ctx, GetAllDCsPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllDCsPaginatedRow{}
	for rows.Next() {
		var i GetAllDCsPaginatedRow
		if err := rows.Scan(
			&i.ID,
			&i.DcNumber,
			&i.DcType,
			&i.ChallanDate,
			&i.ProjectID,
			&i.ProjectName,
			&i.ShipToSummary,
			&i.Status,
			&i.TotalValue,
			&i.LineItemCount,
			&i.TotalQuantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
